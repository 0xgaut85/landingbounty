"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/components/IntroOverlay.tsx":
/*!*****************************************!*\
  !*** ./src/components/IntroOverlay.tsx ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ IntroOverlay; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\nfunction IntroOverlay() {\n    _s();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [isDone, setIsDone] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const animationRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const ctx = canvas.getContext(\"2d\");\n        if (!ctx) return;\n        // Set canvas size\n        const resize = ()=>{\n            canvas.width = window.innerWidth;\n            canvas.height = window.innerHeight;\n        };\n        resize();\n        window.addEventListener(\"resize\", resize);\n        const centerX = canvas.width / 2;\n        const centerY = canvas.height / 2;\n        const maxRadius = Math.sqrt(centerX * centerX + centerY * centerY) * 1.2;\n        let startTime = null;\n        const initialDelay = 600; // ms before animation starts\n        const duration = 3000; // ms for the dissolve animation\n        const animate = (timestamp)=>{\n            if (!startTime) startTime = timestamp;\n            const elapsed = timestamp - startTime;\n            // Clear canvas\n            ctx.fillStyle = \"black\";\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n            if (elapsed < initialDelay) {\n                // Still in initial black phase\n                animationRef.current = requestAnimationFrame(animate);\n                return;\n            }\n            const animationElapsed = elapsed - initialDelay;\n            const progress = Math.min(animationElapsed / duration, 1);\n            // Easing function for smooth reveal\n            const easeOutQuart = 1 - Math.pow(1 - progress, 4);\n            const currentRadius = easeOutQuart * maxRadius;\n            // Create grain/dissolve effect\n            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n            const data = imageData.data;\n            for(let y = 0; y < canvas.height; y++){\n                for(let x = 0; x < canvas.width; x++){\n                    const dx = x - centerX;\n                    const dy = y - centerY;\n                    const distance = Math.sqrt(dx * dx + dy * dy);\n                    // Add noise to the edge for grainy dissolve effect\n                    const noise = (Math.random() - 0.5) * 80;\n                    const edgeDistance = distance - currentRadius + noise;\n                    // Transition zone width (larger = softer edge with more grain)\n                    const transitionWidth = 150 + progress * 100;\n                    if (edgeDistance < -transitionWidth) {\n                        // Inside the clear zone - make transparent\n                        const idx = (y * canvas.width + x) * 4;\n                        data[idx + 3] = 0; // Alpha = 0\n                    } else if (edgeDistance < transitionWidth) {\n                        // In the transition zone - grainy dissolve\n                        const idx = (y * canvas.width + x) * 4;\n                        // Calculate base opacity based on distance\n                        const normalizedDist = (edgeDistance + transitionWidth) / (transitionWidth * 2);\n                        // Add grain effect\n                        const grain = Math.random();\n                        const threshold = normalizedDist * 0.8 + 0.1;\n                        if (grain > threshold) {\n                            data[idx + 3] = 0; // Transparent\n                        } else {\n                            // Keep some pixels black with varying opacity for dense grain\n                            data[idx + 3] = Math.floor(255 * Math.min(1, normalizedDist * 1.5));\n                        }\n                    }\n                // Outside transition zone stays black (default)\n                }\n            }\n            ctx.putImageData(imageData, 0, 0);\n            if (progress < 1) {\n                animationRef.current = requestAnimationFrame(animate);\n            } else {\n                // Animation complete\n                setTimeout(()=>setIsDone(true), 200);\n            }\n        };\n        animationRef.current = requestAnimationFrame(animate);\n        return ()=>{\n            window.removeEventListener(\"resize\", resize);\n            if (animationRef.current) {\n                cancelAnimationFrame(animationRef.current);\n            }\n        };\n    }, []);\n    if (isDone) return null;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n        ref: canvasRef,\n        className: \"fixed inset-0 z-50 pointer-events-none\",\n        style: {\n            background: \"transparent\"\n        }\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\jum\\\\OneDrive\\\\Documents\\\\tech\\\\src\\\\components\\\\IntroOverlay.tsx\",\n        lineNumber: 120,\n        columnNumber: 5\n    }, this);\n}\n_s(IntroOverlay, \"0b6kSygPdtiO7KF6IP0ZJR0k/ME=\");\n_c = IntroOverlay;\nvar _c;\n$RefreshReg$(_c, \"IntroOverlay\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0ludHJvT3ZlcmxheS50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBRW9EO0FBRXJDLFNBQVNHOztJQUN0QixNQUFNQyxZQUFZRiw2Q0FBTUEsQ0FBb0I7SUFDNUMsTUFBTSxDQUFDRyxRQUFRQyxVQUFVLEdBQUdOLCtDQUFRQSxDQUFDO0lBQ3JDLE1BQU1PLGVBQWVMLDZDQUFNQSxDQUFnQjtJQUUzQ0QsZ0RBQVNBLENBQUM7UUFDUixNQUFNTyxTQUFTSixVQUFVSyxPQUFPO1FBQ2hDLElBQUksQ0FBQ0QsUUFBUTtRQUViLE1BQU1FLE1BQU1GLE9BQU9HLFVBQVUsQ0FBQztRQUM5QixJQUFJLENBQUNELEtBQUs7UUFFVixrQkFBa0I7UUFDbEIsTUFBTUUsU0FBUztZQUNiSixPQUFPSyxLQUFLLEdBQUdDLE9BQU9DLFVBQVU7WUFDaENQLE9BQU9RLE1BQU0sR0FBR0YsT0FBT0csV0FBVztRQUNwQztRQUNBTDtRQUNBRSxPQUFPSSxnQkFBZ0IsQ0FBQyxVQUFVTjtRQUVsQyxNQUFNTyxVQUFVWCxPQUFPSyxLQUFLLEdBQUc7UUFDL0IsTUFBTU8sVUFBVVosT0FBT1EsTUFBTSxHQUFHO1FBQ2hDLE1BQU1LLFlBQVlDLEtBQUtDLElBQUksQ0FBQ0osVUFBVUEsVUFBVUMsVUFBVUEsV0FBVztRQUVyRSxJQUFJSSxZQUEyQjtRQUMvQixNQUFNQyxlQUFlLEtBQUssNkJBQTZCO1FBQ3ZELE1BQU1DLFdBQVcsTUFBTSxnQ0FBZ0M7UUFFdkQsTUFBTUMsVUFBVSxDQUFDQztZQUNmLElBQUksQ0FBQ0osV0FBV0EsWUFBWUk7WUFDNUIsTUFBTUMsVUFBVUQsWUFBWUo7WUFFNUIsZUFBZTtZQUNmZCxJQUFJb0IsU0FBUyxHQUFHO1lBQ2hCcEIsSUFBSXFCLFFBQVEsQ0FBQyxHQUFHLEdBQUd2QixPQUFPSyxLQUFLLEVBQUVMLE9BQU9RLE1BQU07WUFFOUMsSUFBSWEsVUFBVUosY0FBYztnQkFDMUIsK0JBQStC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dHMvSW50cm9PdmVybGF5LnRzeD85MWIzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xyXG5cclxuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInJlYWN0XCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBJbnRyb092ZXJsYXkoKSB7XHJcbiAgY29uc3QgY2FudmFzUmVmID0gdXNlUmVmPEhUTUxDYW52YXNFbGVtZW50PihudWxsKTtcclxuICBjb25zdCBbaXNEb25lLCBzZXRJc0RvbmVdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gIGNvbnN0IGFuaW1hdGlvblJlZiA9IHVzZVJlZjxudW1iZXIgfCBudWxsPihudWxsKTtcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xyXG4gICAgaWYgKCFjYW52YXMpIHJldHVybjtcclxuXHJcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG4gICAgaWYgKCFjdHgpIHJldHVybjtcclxuXHJcbiAgICAvLyBTZXQgY2FudmFzIHNpemVcclxuICAgIGNvbnN0IHJlc2l6ZSA9ICgpID0+IHtcclxuICAgICAgY2FudmFzLndpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XHJcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XHJcbiAgICB9O1xyXG4gICAgcmVzaXplKCk7XHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCByZXNpemUpO1xyXG5cclxuICAgIGNvbnN0IGNlbnRlclggPSBjYW52YXMud2lkdGggLyAyO1xyXG4gICAgY29uc3QgY2VudGVyWSA9IGNhbnZhcy5oZWlnaHQgLyAyO1xyXG4gICAgY29uc3QgbWF4UmFkaXVzID0gTWF0aC5zcXJ0KGNlbnRlclggKiBjZW50ZXJYICsgY2VudGVyWSAqIGNlbnRlclkpICogMS4yO1xyXG5cclxuICAgIGxldCBzdGFydFRpbWU6IG51bWJlciB8IG51bGwgPSBudWxsO1xyXG4gICAgY29uc3QgaW5pdGlhbERlbGF5ID0gNjAwOyAvLyBtcyBiZWZvcmUgYW5pbWF0aW9uIHN0YXJ0c1xyXG4gICAgY29uc3QgZHVyYXRpb24gPSAzMDAwOyAvLyBtcyBmb3IgdGhlIGRpc3NvbHZlIGFuaW1hdGlvblxyXG5cclxuICAgIGNvbnN0IGFuaW1hdGUgPSAodGltZXN0YW1wOiBudW1iZXIpID0+IHtcclxuICAgICAgaWYgKCFzdGFydFRpbWUpIHN0YXJ0VGltZSA9IHRpbWVzdGFtcDtcclxuICAgICAgY29uc3QgZWxhcHNlZCA9IHRpbWVzdGFtcCAtIHN0YXJ0VGltZTtcclxuXHJcbiAgICAgIC8vIENsZWFyIGNhbnZhc1xyXG4gICAgICBjdHguZmlsbFN0eWxlID0gXCJibGFja1wiO1xyXG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuXHJcbiAgICAgIGlmIChlbGFwc2VkIDwgaW5pdGlhbERlbGF5KSB7XHJcbiAgICAgICAgLy8gU3RpbGwgaW4gaW5pdGlhbCBibGFjayBwaGFzZVxyXG4gICAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgYW5pbWF0aW9uRWxhcHNlZCA9IGVsYXBzZWQgLSBpbml0aWFsRGVsYXk7XHJcbiAgICAgIGNvbnN0IHByb2dyZXNzID0gTWF0aC5taW4oYW5pbWF0aW9uRWxhcHNlZCAvIGR1cmF0aW9uLCAxKTtcclxuICAgICAgXHJcbiAgICAgIC8vIEVhc2luZyBmdW5jdGlvbiBmb3Igc21vb3RoIHJldmVhbFxyXG4gICAgICBjb25zdCBlYXNlT3V0UXVhcnQgPSAxIC0gTWF0aC5wb3coMSAtIHByb2dyZXNzLCA0KTtcclxuICAgICAgY29uc3QgY3VycmVudFJhZGl1cyA9IGVhc2VPdXRRdWFydCAqIG1heFJhZGl1cztcclxuXHJcbiAgICAgIC8vIENyZWF0ZSBncmFpbi9kaXNzb2x2ZSBlZmZlY3RcclxuICAgICAgY29uc3QgaW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICBjb25zdCBkYXRhID0gaW1hZ2VEYXRhLmRhdGE7XHJcblxyXG4gICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGNhbnZhcy5oZWlnaHQ7IHkrKykge1xyXG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgY2FudmFzLndpZHRoOyB4KyspIHtcclxuICAgICAgICAgIGNvbnN0IGR4ID0geCAtIGNlbnRlclg7XHJcbiAgICAgICAgICBjb25zdCBkeSA9IHkgLSBjZW50ZXJZO1xyXG4gICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xyXG5cclxuICAgICAgICAgIC8vIEFkZCBub2lzZSB0byB0aGUgZWRnZSBmb3IgZ3JhaW55IGRpc3NvbHZlIGVmZmVjdFxyXG4gICAgICAgICAgY29uc3Qgbm9pc2UgPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiA4MDtcclxuICAgICAgICAgIGNvbnN0IGVkZ2VEaXN0YW5jZSA9IGRpc3RhbmNlIC0gY3VycmVudFJhZGl1cyArIG5vaXNlO1xyXG5cclxuICAgICAgICAgIC8vIFRyYW5zaXRpb24gem9uZSB3aWR0aCAobGFyZ2VyID0gc29mdGVyIGVkZ2Ugd2l0aCBtb3JlIGdyYWluKVxyXG4gICAgICAgICAgY29uc3QgdHJhbnNpdGlvbldpZHRoID0gMTUwICsgcHJvZ3Jlc3MgKiAxMDA7XHJcblxyXG4gICAgICAgICAgaWYgKGVkZ2VEaXN0YW5jZSA8IC10cmFuc2l0aW9uV2lkdGgpIHtcclxuICAgICAgICAgICAgLy8gSW5zaWRlIHRoZSBjbGVhciB6b25lIC0gbWFrZSB0cmFuc3BhcmVudFxyXG4gICAgICAgICAgICBjb25zdCBpZHggPSAoeSAqIGNhbnZhcy53aWR0aCArIHgpICogNDtcclxuICAgICAgICAgICAgZGF0YVtpZHggKyAzXSA9IDA7IC8vIEFscGhhID0gMFxyXG4gICAgICAgICAgfSBlbHNlIGlmIChlZGdlRGlzdGFuY2UgPCB0cmFuc2l0aW9uV2lkdGgpIHtcclxuICAgICAgICAgICAgLy8gSW4gdGhlIHRyYW5zaXRpb24gem9uZSAtIGdyYWlueSBkaXNzb2x2ZVxyXG4gICAgICAgICAgICBjb25zdCBpZHggPSAoeSAqIGNhbnZhcy53aWR0aCArIHgpICogNDtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBiYXNlIG9wYWNpdHkgYmFzZWQgb24gZGlzdGFuY2VcclxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZERpc3QgPSAoZWRnZURpc3RhbmNlICsgdHJhbnNpdGlvbldpZHRoKSAvICh0cmFuc2l0aW9uV2lkdGggKiAyKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIEFkZCBncmFpbiBlZmZlY3RcclxuICAgICAgICAgICAgY29uc3QgZ3JhaW4gPSBNYXRoLnJhbmRvbSgpO1xyXG4gICAgICAgICAgICBjb25zdCB0aHJlc2hvbGQgPSBub3JtYWxpemVkRGlzdCAqIDAuOCArIDAuMTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChncmFpbiA+IHRocmVzaG9sZCkge1xyXG4gICAgICAgICAgICAgIGRhdGFbaWR4ICsgM10gPSAwOyAvLyBUcmFuc3BhcmVudFxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIC8vIEtlZXAgc29tZSBwaXhlbHMgYmxhY2sgd2l0aCB2YXJ5aW5nIG9wYWNpdHkgZm9yIGRlbnNlIGdyYWluXHJcbiAgICAgICAgICAgICAgZGF0YVtpZHggKyAzXSA9IE1hdGguZmxvb3IoMjU1ICogTWF0aC5taW4oMSwgbm9ybWFsaXplZERpc3QgKiAxLjUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgLy8gT3V0c2lkZSB0cmFuc2l0aW9uIHpvbmUgc3RheXMgYmxhY2sgKGRlZmF1bHQpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBjdHgucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XHJcblxyXG4gICAgICBpZiAocHJvZ3Jlc3MgPCAxKSB7XHJcbiAgICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gQW5pbWF0aW9uIGNvbXBsZXRlXHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiBzZXRJc0RvbmUodHJ1ZSksIDIwMCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XHJcblxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgcmVzaXplKTtcclxuICAgICAgaWYgKGFuaW1hdGlvblJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uUmVmLmN1cnJlbnQpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH0sIFtdKTtcclxuXHJcbiAgaWYgKGlzRG9uZSkgcmV0dXJuIG51bGw7XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8Y2FudmFzXHJcbiAgICAgIHJlZj17Y2FudmFzUmVmfVxyXG4gICAgICBjbGFzc05hbWU9XCJmaXhlZCBpbnNldC0wIHotNTAgcG9pbnRlci1ldmVudHMtbm9uZVwiXHJcbiAgICAgIHN0eWxlPXt7IGJhY2tncm91bmQ6IFwidHJhbnNwYXJlbnRcIiB9fVxyXG4gICAgLz5cclxuICApO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZVJlZiIsIkludHJvT3ZlcmxheSIsImNhbnZhc1JlZiIsImlzRG9uZSIsInNldElzRG9uZSIsImFuaW1hdGlvblJlZiIsImNhbnZhcyIsImN1cnJlbnQiLCJjdHgiLCJnZXRDb250ZXh0IiwicmVzaXplIiwid2lkdGgiLCJ3aW5kb3ciLCJpbm5lcldpZHRoIiwiaGVpZ2h0IiwiaW5uZXJIZWlnaHQiLCJhZGRFdmVudExpc3RlbmVyIiwiY2VudGVyWCIsImNlbnRlclkiLCJtYXhSYWRpdXMiLCJNYXRoIiwic3FydCIsInN0YXJ0VGltZSIsImluaXRpYWxEZWxheSIsImR1cmF0aW9uIiwiYW5pbWF0ZSIsInRpbWVzdGFtcCIsImVsYXBzZWQiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImFuaW1hdGlvbkVsYXBzZWQiLCJwcm9ncmVzcyIsIm1pbiIsImVhc2VPdXRRdWFydCIsInBvdyIsImN1cnJlbnRSYWRpdXMiLCJpbWFnZURhdGEiLCJnZXRJbWFnZURhdGEiLCJkYXRhIiwieSIsIngiLCJkeCIsImR5IiwiZGlzdGFuY2UiLCJub2lzZSIsInJhbmRvbSIsImVkZ2VEaXN0YW5jZSIsInRyYW5zaXRpb25XaWR0aCIsImlkeCIsIm5vcm1hbGl6ZWREaXN0IiwiZ3JhaW4iLCJ0aHJlc2hvbGQiLCJmbG9vciIsInB1dEltYWdlRGF0YSIsInNldFRpbWVvdXQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJyZWYiLCJjbGFzc05hbWUiLCJzdHlsZSIsImJhY2tncm91bmQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/IntroOverlay.tsx\n"));

/***/ })

});